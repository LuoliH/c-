### 题目
c语言实现魔方阵

### 问题描述
编写程序，实现如下表所示的5-魔方阵。
17	24	1	8	15
23	5	7	14	16
4	6	13	20	22
10	12	19	21	3
11	18	25	2	9
5-魔方阵
### 问题分析
所谓“n-魔方阵”，指的是使用1〜n2共n2个自然数排列成一个n×n的方阵，其中n为奇数；该方阵的每行、每列及对角线元素之和都相等，并为一个只与n有关的常数，该常数为n×(n2+1)/2。

例如5-魔方阵，其第一行、第一列及主对角线上各元素之和如下：
第一行元素之和：17+24+1+8+15=65
第一列元素之和：17+23+4+10+11=65
主对角线上元素之和：17+5+13+21+9=65

而 n×(n2+1)/2=5×(52+1)/2=65 可以验证，5-魔方阵中其余各行、各列及副对角线上的元素之和也都为65。

假定阵列的行列下标都从0开始，则魔方阵的生成方法为：在第0行中间置1，对从2开始的其余n2-1个数依次按下列规则存放：
(1) 假定当前数的下标为(i，j)，则下一个数的放置位置为当前位置的右上方，即下标为(i-1，j+1)的位置。
(2) 如果当前数在第0行，即i-1小于0，则将下一个数放在最后一行的下一列上，即下标为(n-1，j+1)的位置。
(3) 如果当前数在最后一列上，即j+1大于n-1，则将下一个数放在上一行的第一列上，即下标为(i-1，0)的位置。
(4) 如果当前数是n的倍数，则将下一个数直接放在当前位置的正下方，即下标为(i+1，j）的位置。
~~~ c
#include<stdio.h>
#define N 5
int main()
{
    int a[N][N]={0}, i, j, k, t, x, y;
    i=0;  /*自然数1的行标*/
    j=N/2;  /*自然数1的列标*/
    t=N-1;  /*最后一行、最后一列的下标*/
    for(k=1; k<=N*N; k++)
    {
        a[i][j]=k;
        x=i;
        y=j;
        if(i == 0)
            i=t;
        else
            i=i-1;
        if(j != t)
            j=j+1;
        else
            j=0;
        if(a[i][j]!=0)
        {
            i=x+1;
            j=y;
        }
    }
    printf("生成的5-魔方阵为：");
    for(i=0; i<N; i++)
    {
        printf("\n");
        for(j=0; j<N; j++)
        {
            printf("%3d", a[i][j]);
        }
    }
    printf("\n");
    return 0;
}
运行结果：
生成的5-魔方阵为：
17 24  1  8 15
23  5  7 14 16
 4  6 13 20 22
10 12 19 21  3
11 18 25  2  9
~~~
